1
00:00:00,030 --> 00:00:03,360
所以我是DanoClifford，我领导的团队

2
00:00:03,360 --> 00:00:06,899
在德国的Google慕尼黑工作

3
00:00:06,899 --> 00:00:11,190
v8这是一个JavaScript引擎你可能听说过这个用法

4
00:00:11,190 --> 00:00:15,540
谷歌浏览器和nodejs，所以我会请求一点点观众

5
00:00:15,540 --> 00:00:20,060
实际参加这里的人在客户端写入JavaScript

6
00:00:20,060 --> 00:00:25,320
这很好服务器端哇谁好

7
00:00:25,320 --> 00:00:28,920
其实听说这8个都没错

8
00:00:28,920 --> 00:00:33,480
在我之前，这很好进入我的谈话的实际哑巴

9
00:00:33,480 --> 00:00:37,920
喜欢为排序设置框架讨论和我想要的主题

10
00:00:37,920 --> 00:00:40,739
今天与你分享，这是一个

11
00:00:40,739 --> 00:00:44,190
一点点mccoshen艾里的故事，所以我

12
00:00:44,190 --> 00:00:48,840
几乎所有人都在这个行业超过25年，我见过很多

13
00:00:48,840 --> 00:00:53,610
梦想成真，而不是所有这些梦想已经完成了你的方式

14
00:00:53,610 --> 00:00:58,289
预期，所以我想要的报价与大家分享一下就是了

15
00:00:58,289 --> 00:01:03,199
当心你在你想要什么的因为你可能会在你的中年

16
00:01:03,199 --> 00:01:06,689
所以这个报价实际上是归因于

17
00:01:06,689 --> 00:01:11,460
一个比较有名的有时是抒情诗人

18
00:01:11,460 --> 00:01:14,250
哲学家兼政治家约翰

19
00:01:14,250 --> 00:01:17,790
沃尔夫冈・冯・歌德，这是一种

20
00:01:17,790 --> 00:01:22,110
归因于一点点的来源更常见的短语，你可能有

21
00:01:22,110 --> 00:01:24,900
也听说过这是小心你在生活中希望什么，因为它

22
00:01:24,900 --> 00:01:29,490
可能会成真，我给出的理由事实证明，现在情况是这样的

23
00:01:29,490 --> 00:01:34,320
那显然不太知名哲学家并不是非常有才华的人

24
00:01:34,320 --> 00:01:37,140
作家竟然出现了报价，这是非常

25
00:01:37,140 --> 00:01:40,439
作为软件适用于我们的空间

26
00:01:40,439 --> 00:01:44,850
开发人员和各种产品和复杂系统的开发人员

27
00:01:44,850 --> 00:01:48,689
像这样要小心你的优化，因为它

28
00:01:48,689 --> 00:01:52,409
可能会更快，没有别的等等

29
00:01:52,409 --> 00:01:57,060
记住这一点作为排序框架讨论我想要的

30
00:01:57,060 --> 00:02:01,790
今天你与我想

31
00:02:01,790 --> 00:02:06,730
告诉你我的概述这是一个概述

32
00:02:06,730 --> 00:02:10,480
我喜欢从这开始，它很有趣

33
00:02:10,480 --> 00:02:14,770
我想谈谈我想开始出用我发出的声音

34
00:02:14,770 --> 00:02:19,330
真正的官方称为合成基准困境这是基准如何

35
00:02:19,330 --> 00:02:22,270
可以变坏我想跟你说一个

36
00:02:22,270 --> 00:02:25,930
关于V8如何工作以及如何工作的一点点这在过去几年中已经发生了变化

37
00:02:25,930 --> 00:02:30,910
特别是因为它给了一个框架如何我们的教训

38
00:02:30,910 --> 00:02:36,790
在过去几年和我学会了认为这里有实际的教训适用于任何开发

39
00:02:36,790 --> 00:02:41,470
大型软件系统的教训当然了解了一个重要的部分

40
00:02:41,470 --> 00:02:47,290
这一点，我喜欢那种专注于这个东西叫自我托管vs

41
00:02:47,290 --> 00:02:51,280
优化的内置插件，我会进入

42
00:02:51,280 --> 00:02:55,360
那是什么，所以不要担心在这一点和最后一件事情喜欢做

43
00:02:55,360 --> 00:02:59,590
告诉你我们曾经做过什么想通了，我们的教训

44
00:02:59,590 --> 00:03:03,580
学到了很重要我们做了一些事关于它，这是所谓的部分

45
00:03:03,580 --> 00:03:06,010
构建内置的构建器和代码

46
00:03:06,010 --> 00:03:10,270
停止汇编，让我们进入它

47
00:03:10,270 --> 00:03:14,170
我想要的综合基准困境

48
00:03:14,170 --> 00:03:18,780
沿着这条记忆道走一点

49
00:03:18,780 --> 00:03:22,660
vietze存在了，而现在，当它首次出现时，铬是第一次

50
00:03:22,660 --> 00:03:26,980
发布了使用的基准以测试JavaScript速度均会有什么新

51
00:03:26,980 --> 00:03:31,660
现在回想起来叫微基准如此SunSpiderkracken他们

52
00:03:31,660 --> 00:03:36,010
在当时是有用的，因为他们测试了某些关键功能

53
00:03:36,010 --> 00:03:39,520
JavaScript运行时非常重要小型应用程序已经运行

54
00:03:39,520 --> 00:03:44,280
随着应用程序变得越来越大，

55
00:03:44,280 --> 00:03:47,230
V8是负责这部分是

56
00:03:47,230 --> 00:03:52,120
应用程序变得更加可能需要复杂的厚度类型

57
00:03:52,120 --> 00:03:54,910
在基准测试也成为

58
00:03:54,910 --> 00:03:58,480
在2012年左右或2012年左右更大

59
00:03:58,480 --> 00:04:01,209
发布了一个称为辛烷和基准的基准

60
00:04:01,209 --> 00:04:04,930
它试图代表更广泛的范围

61
00:04:04,930 --> 00:04:09,250
我们可以使用用例用例

62
00:04:09,250 --> 00:04:14,950
优化，以便我们做一个为实际优化提供更好的工作我们找到的应用程序和

63
00:04:14,950 --> 00:04:19,410
事实证明，在野外发现

64
00:04:19,410 --> 00:04:23,610
我们有一个相当得到它的权利V8引擎做

65
00:04:23,610 --> 00:04:27,480
优化的一个很好的工作我们有SunSpider的基准

66
00:04:27,480 --> 00:04:32,010
克拉肯辛烷但我们很重要意识到那些基准没有

67
00:04:32,010 --> 00:04:36,300
真正反映了在这个过程中发生了什么狂野，所以我们创建了一个内部

68
00:04:36,300 --> 00:04:41,250
基准在哪里常见的网站和我们通过我们的一些自动化来运行它们

69
00:04:41,250 --> 00:04:45,300
我们测量了他们的位置他们花时间在那里

70
00:04:45,300 --> 00:04:48,980
一些有趣的结果出来了这所以这看起来非常复杂

71
00:04:48,980 --> 00:04:52,230
你不需要了解所有的东西细节在这里，但我想指出

72
00:04:52,230 --> 00:04:55,980
在左边是列表可能是一堆网站的一部分

73
00:04:55,980 --> 00:04:59,220
很难从后面读取排，但其中一些可能看起来

74
00:04:59,220 --> 00:05:03,290
熟悉你和每个这些酒吧

75
00:05:03,290 --> 00:05:06,090
旁边的网站是一个分布的

76
00:05:06,090 --> 00:05:10,290
时间是什么时候铬实际上在做什么

77
00:05:10,290 --> 00:05:14,460
您正在加载该网站和我们创建这些测试，以便我们可以运行

78
00:05:14,460 --> 00:05:18,480
他们一次又一次地能够做到优化并查看这些配置文件

79
00:05:18,480 --> 00:05:22,080
会改变这里要注意的事情在底部有一个传说和

80
00:05:22,080 --> 00:05:26,580
你会看到，我们所花费的时间网站上的是真有种跨越

81
00:05:26,580 --> 00:05:29,940
我们花了一些时间在董事会JavaScript，但我们也花时间

82
00:05:29,940 --> 00:05:34,530
在Dom中闪烁的回调例如我们也花时间解析

83
00:05:34,530 --> 00:05:39,180
我会回到那个，否则我会证明这一点哪里适合以后，并且有一个

84
00:05:39,180 --> 00:05:43,050
我们正在做的其他各种事情当我们现在载入网站

85
00:05:43,050 --> 00:05:47,700
这里有趣的是你看到每一个网站是一点点

86
00:05:47,700 --> 00:05:52,290
不同但你确实看到了一些模式在这里或至少有一种模式

87
00:05:52,290 --> 00:05:57,260
这对我们和那非常有趣右边是粉红色的酒吧

88
00:05:57,260 --> 00:06:01,530
相对较小，全部为25％或更少

89
00:06:01,530 --> 00:06:04,860
我们测试过的网站和那个

90
00:06:04,860 --> 00:06:08,910
令人惊讶，因为这是JavaScript片断，这是花费的时间

91
00:06:08,910 --> 00:06:12,210
实际执行JavaScript，为什么这很有趣

92
00:06:12,210 --> 00:06:17,130
好吧，如果你看看八分辛烷值基准我们出来，并与英寸

93
00:06:17,130 --> 00:06:20,640
2012看看辛烷花在哪里的时间

94
00:06:20,640 --> 00:06:23,820
几乎全是粉红色或三分之二

95
00:06:23,820 --> 00:06:28,350
四分之三粉红色这意味着我们多年来一直在优化

96
00:06:28,350 --> 00:06:32,460
实际上并不代表什么是赫然出现在网页

97
00:06:32,460 --> 00:06:37,290
好了，这是我们需要解决的东西并在过去的几年里我们已经

98
00:06:37,290 --> 00:06:41,520
一直在努力解决这个问题我们已经做到这一点的方法是尝试寻找更多

99
00:06:41,520 --> 00:06:46,530
在真实的网站和服务器端在真实的nodejs表现

100
00:06:46,530 --> 00:06:50,670
应用程序，以便我们可以调优v8我们的工作负载类型

101
00:06:50,670 --> 00:06:54,920
通常在野外看到，而不仅仅是我们在基准测试中看到的那些

102
00:06:54,920 --> 00:06:57,420
幸运的是有几个

103
00:06:57,420 --> 00:07:02,460
基准现在更多代表这些工作负载的那

104
00:07:02,460 --> 00:07:05,580
我们希望为您所看到的进行优化在真实世界的网站上

105
00:07:05,580 --> 00:07:10,500
速度计，它模拟MVC做的事情

106
00:07:10,500 --> 00:07:14,730
应用程序，与一堆标准

107
00:07:14,730 --> 00:07:19,800
JavaScript框架，我们可以测试并看看铬和V8需要多长时间

108
00:07:19,800 --> 00:07:24,360
这些半真实的各个部分应用程序，也有六个

109
00:07:24,360 --> 00:07:28,710
这是测试最新的基准

110
00:07:28,710 --> 00:07:32,040
ACMA脚本功能等es6功能你会在最近几次看到

111
00:07:32,040 --> 00:07:35,850
几年来，我们用v8获得了更快的速度在这些非常好的工作负载中

112
00:07:35,850 --> 00:07:41,400
因为这个消息直接转化为你会表现的类型希望在你的和你的网站上看到

113
00:07:41,400 --> 00:07:46,320
在nodejs的服务器端真的

114
00:07:46,320 --> 00:07:50,850
所有这一切的重要教训是我们意识到如果你

115
00:07:50,850 --> 00:07:53,400
有用于优化的基准

116
00:07:53,400 --> 00:07:57,930
一些特定的或表明一个具体的问题，你会结束

117
00:07:57,930 --> 00:08:02,150
优化这个问题，那可以成为一个陷阱的一点点，因为

118
00:08:02,150 --> 00:08:04,770
优化乐趣，我们喜欢这样做

119
00:08:04,770 --> 00:08:09,540
v8团队但是如果你有错误的话目标，你将继续努力实现

120
00:08:09,540 --> 00:08:15,270
目标，除非你知道你什么时候完成而且你可能冒着忽视的风险

121
00:08:15,270 --> 00:08:20,040
具体过程中的其他事情我们意识到什么，并且你看到了

122
00:08:20,040 --> 00:08:25,140
那些图是之前的大多数应用程序的性能概要

123
00:08:25,140 --> 00:08:29,070
有一种方式是全面的有时间花在JavaScript解析上

124
00:08:29,070 --> 00:08:33,600
大教堂很多不同的地方，如果你只是特别优化

125
00:08:33,600 --> 00:08:38,400
其中一个切片，那么你就不会冒险拥有一贯的平台

126
00:08:38,400 --> 00:08:42,690
高性能，所以有这个概念始终如一的基线

127
00:08:42,690 --> 00:08:47,879
这是一种咒语我们已经在过去的几个月里年份确保不仅仅是具体使用

128
00:08:47,879 --> 00:08:52,769
案例很快，但JavaScript和web平台和nodejs速度很快

129
00:08:52,769 --> 00:08:58,589
全面的感觉没问题，呼吸

130
00:08:58,589 --> 00:09:02,220
所以考虑到这一点，我想谈一谈

131
00:09:02,220 --> 00:09:06,120
关于V8如何工作以及如何工作的一点点我们在过去的几个月里改变了它

132
00:09:06,120 --> 00:09:08,910
这个新的重点放在铁路上

133
00:09:08,910 --> 00:09:13,259
性能两项技术我想

134
00:09:13,259 --> 00:09:15,889
突出讨论这个问题

135
00:09:15,889 --> 00:09:20,870
点火和涡轮风扇我们花了最近几年的建设

136
00:09:20,870 --> 00:09:23,009
基础新技术进入v8

137
00:09:23,009 --> 00:09:27,269
这使它在现实世界中变得更快

138
00:09:27,269 --> 00:09:31,439
并涵盖更广泛的使用范围

139
00:09:31,439 --> 00:09:35,490
第一个案例是点火翻译点火解释器

140
00:09:35,490 --> 00:09:40,470
为我们提供了基准性能我们需要一致的基线性能如果我们正在运行各种不同的

141
00:09:40,470 --> 00:09:43,980
JavaScript我们有涡轮风扇

142
00:09:43,980 --> 00:09:46,740
优化编译器哪个需要一个

143
00:09:46,740 --> 00:09:50,879
看最常见还是最多经常执行的代码和

144
00:09:50,879 --> 00:09:55,680
然后选择性地优化这些这两个新组件我们能够做到

145
00:09:55,680 --> 00:10:00,240
处理更广泛的用例比我们以前做的

146
00:10:00,240 --> 00:10:05,790
我不会详述所有的细节我们以前在v8中做过的事情，但截至目前

147
00:10:05,790 --> 00:10:09,990
铬59所以这差不多一年现在这两种技术是主要的

148
00:10:09,990 --> 00:10:15,959
v8中的这些让我们可以解决这个问题性能需求的广泛使用

149
00:10:15,959 --> 00:10:22,259
案件好吧，让我们来谈谈一点点

150
00:10:22,259 --> 00:10:25,350
v8如何使用这两种技术

151
00:10:25,350 --> 00:10:29,730
点火和涡轮风扇和集成他们进入它的管道这是一个有用的

152
00:10:29,730 --> 00:10:34,709
模型也回想那个一套图表，我显示了哪里

153
00:10:34,709 --> 00:10:39,240
在不同的酒吧x的分布这将会告诉你那些地方

154
00:10:39,240 --> 00:10:42,600
来自或其中一些来自如此v8如何运作，我们会采取你的

155
00:10:42,600 --> 00:10:46,769
JavaScript代码，它通过一个解析器和解析器将它变成一个

156
00:10:46,769 --> 00:10:49,350
抽象语法树这是如此

157
00:10:49,350 --> 00:10:52,829
标准的计算机科学的东西和

158
00:10:52,829 --> 00:10:55,709
那么抽象树语法树就会得到

159
00:10:55,709 --> 00:10:59,760
变成了解释器字节码解释器字节码

160
00:10:59,760 --> 00:11:04,470
我通过点火运行在上一张幻灯片中提到，就像我们一样

161
00:11:04,470 --> 00:11:07,950
通过该代码运行该代码解释器我们不只是执行

162
00:11:07,950 --> 00:11:12,060
我们正在寻找从信号执行我们稍后可以使用的代码

163
00:11:12,060 --> 00:11:16,980
优化Java脚本的一种棘手的语言，它非常类型

164
00:11:16,980 --> 00:11:20,640
它是狂野的西部耶，你可以创造一个一次变量，下一个是整数

165
00:11:20,640 --> 00:11:25,260
当下一次它是一个字符串时对象，并没有真正的信号

166
00:11:25,260 --> 00:11:29,970
预先v8什么你想要什么你的意图是或有几个信号

167
00:11:29,970 --> 00:11:33,330
我会真的进入一点没有那些明确的类型更是如此

168
00:11:33,330 --> 00:11:37,860
你会用其他语言找到它V8拥有真正了解一点点

169
00:11:37,860 --> 00:11:40,920
关于你之前的代码连接之前它可以让你发胖

170
00:11:40,920 --> 00:11:46,470
让它更快，所以解释者是什么它是否运行你的字节码而

171
00:11:46,470 --> 00:11:49,830
收集我们称之为这种类型的反馈

172
00:11:49,830 --> 00:11:55,680
反馈，然后是反馈发送最热门的JavaScript代码

173
00:11:55,680 --> 00:11:59,490
码到涡扇编译器在哪里你

174
00:11:59,490 --> 00:12:02,940
JavaScript被选择性地优化变成运行的机器代码

175
00:12:02,940 --> 00:12:08,400
真的很快，所以几个高层

176
00:12:08,400 --> 00:12:11,670
关于这个新系统和观察的观察为什么它实际上比我们的更好

177
00:12:11,670 --> 00:12:16,560
之前我会回到这个实际上这看起来很复杂

178
00:12:16,560 --> 00:12:20,430
很简单，你注意到有箭在这里我们去从一个阶段到

179
00:12:20,430 --> 00:12:24,450
接下来有几个例外我不会进入这里，但这个想法是

180
00:12:24,450 --> 00:12:30,090
我们可以推测这个系统因为这些单位是独立的它们之间的接口是

181
00:12:30,090 --> 00:12:34,290
相对明确的定义它不是

182
00:12:34,290 --> 00:12:38,370
情况并非总是如此v8，它非常干净而且那样

183
00:12:38,370 --> 00:12:41,520
帮助我们有一些重要的问

184
00:12:41,520 --> 00:12:44,460
对于某些重要的属性来说

185
00:12:44,460 --> 00:12:49,230
首先运行时间都是点火和涡轮风扇支持整个

186
00:12:49,230 --> 00:12:53,520
这些之前的JavaScript语言技术被运送它不是

187
00:12:53,520 --> 00:12:58,350
我们可以优化所有的情况下JavaScript是我的方式

188
00:12:58,350 --> 00:13:04,110
让你们中的很多人都是你们中的一些人知道的是，尝试赶上这样的例外结构化的异常处理不是

189
00:13:04,110 --> 00:13:07,470
在V的旧版本中进行了优化

190
00:13:07,470 --> 00:13:11,940
问题，因为它仅限于一个有选择地设置语言功能

191
00:13:11,940 --> 00:13:17,310
正在优化它的限制你可以做一个开发商和你可以依靠什么来快速进入

192
00:13:17,310 --> 00:13:20,730
你的应用程序现在变成涡轮风扇

193
00:13:20,730 --> 00:13:24,930
点火优化了整个JavaScript他们提供的语言一致

194
00:13:24,930 --> 00:13:28,380
性能我提到了一致

195
00:13:28,380 --> 00:13:32,490
基准性能作为一种a我们相信这两个咒语

196
00:13:32,490 --> 00:13:36,090
我们已经解决了一些技术我们曾经习惯的有趣问题

197
00:13:36,090 --> 00:13:41,910
有一个让我们给你软关于基线的保证

198
00:13:41,910 --> 00:13:46,830
你的代码的性能和我提到的在我知道那个之前简单

199
00:13:46,830 --> 00:13:50,520
图片与信息流动通过v8看起来像很多小

200
00:13:50,520 --> 00:13:53,730
盒子，但它曾经是有的这些盒子之间的箭头是

201
00:13:53,730 --> 00:13:57,750
有点不直观，很难有关这个新系统的原因我们

202
00:13:57,750 --> 00:14:01,860
能够创造的东西，是简单，不是更全面

203
00:14:01,860 --> 00:14:04,830
编译器和我们的编译器

204
00:14:04,830 --> 00:14:09,300
收到现在这是一件将在讨论中变得重要

205
00:14:09,300 --> 00:14:13,890
我们有后来的简单，这是一个我会提到的技术要点

206
00:14:13,890 --> 00:14:19,470
最后是简单可以是你的朋友，因为如果你投入太多

207
00:14:19,470 --> 00:14:24,150
复杂性前沿，那么复杂性是你一次又一次付出的东西

208
00:14:24,150 --> 00:14:27,960
并且如果你创建一个简单的系统一开始就很容易推理

209
00:14:27,960 --> 00:14:30,240
关于衡量它很容易，很容易

210
00:14:30,240 --> 00:14:33,990
实际上确定问题并修复

211
00:14:33,990 --> 00:14:39,000
错误与和不顾一切就这么维持v8中正在进行的复杂的事情

212
00:14:39,000 --> 00:14:42,710
这是我们的设计目标让事情尽可能的简单

213
00:14:42,710 --> 00:14:48,030
必要的复杂性，但只有必要的复杂性，因为更简单

214
00:14:48,030 --> 00:14:50,850
系统只是简单的推理

215
00:14:50,850 --> 00:14:56,490
更容易修复和建立一个复杂的系统，它变得越来越大大

216
00:14:56,490 --> 00:14:59,640
在某些时候没有那么简单你只是你失去了你不能

217
00:14:59,640 --> 00:15:04,130
更长的举动我谈到反馈和

218
00:15:04,130 --> 00:15:07,590
我们如何生成或如何优化代码

219
00:15:07,590 --> 00:15:10,490
在第8版基于我们产生的反馈

220
00:15:10,490 --> 00:15:14,970
所以我想进入的一点点

221
00:15:14,970 --> 00:15:19,740
深入了解这是如何完成的，因为我后来的例子理解这一点

222
00:15:19,740 --> 00:15:24,810
事实证明，我们使用这一点很重要机制调用内联缓存任何人

223
00:15:24,810 --> 00:15:30,020
永远学习或听说有一线缓存哦，好吧哇

224
00:15:30,020 --> 00:15:32,420
一个是就是这样的优秀

225
00:15:32,420 --> 00:15:37,190
所以内联缓存，所以这是我的好谈到这个内联缓存是我们的

226
00:15:37,190 --> 00:15:42,950
我们用来进行操作的机制在翻译和翻译都更快

227
00:15:42,950 --> 00:15:48,050
记录类型反馈或信息对于以后的优化是必要的

228
00:15:48,050 --> 00:15:53,510
涡轮家庭，我想给你一个这是如何工作的例子，所以这是一个例子

229
00:15:53,510 --> 00:15:56,120
非常简单的功能在这里，要么

230
00:15:56,120 --> 00:16:00,800
返回数组或者第一个元素未定义取决于大小

231
00:16:00,800 --> 00:16:05,780
我认为这很漂亮直截了当的代码理解为

232
00:16:05,780 --> 00:16:07,760
您将此代码发送到该管道

233
00:16:07,760 --> 00:16:12,830
我在第一次阐述之前概述了它生成字节码，这是什么

234
00:16:12,830 --> 00:16:15,440
字节码看起来像是不会出汗的

235
00:16:15,440 --> 00:16:20,240
字节代码的细节看起来非常类似汇编语言历史的一种

236
00:16:20,240 --> 00:16:23,540
是，我会进入重要的事情

237
00:16:23,540 --> 00:16:29,420
现在我们在几分钟内就可以创建我们也建立了这样的字节码

238
00:16:29,420 --> 00:16:33,650
我们可以收集关于它的信息它运行并且有这个东西叫

239
00:16:33,650 --> 00:16:38,350
这是一种反馈向量与字节码一起携手

240
00:16:38,350 --> 00:16:42,200
并让我有点想要你

241
00:16:42,200 --> 00:16:46,580
以显示这三个部分是怎样的

242
00:16:46,580 --> 00:16:52,250
适合在一起，所以你会看到的我们在函数中做的第一件事是问为数组的长度和from

243
00:16:52,250 --> 00:16:55,730
我们是从那个声明来的

244
00:16:55,730 --> 00:16:59,030
在解释器中生成一个字节码这里也强调了这一点

245
00:16:59,030 --> 00:17:04,040
名称专有名称属性加载具有命名属性的累加器不会

246
00:17:04,040 --> 00:17:08,180
再次为这里的细节出汗，但你注意到在支架零在

247
00:17:08,180 --> 00:17:12,470
最后实际上是指最后一个到这个反馈向量中的一个索引

248
00:17:12,470 --> 00:17:16,520
这些突出了它的高峰部分在这张幻灯片上的代码就是各种各样的

249
00:17:16,520 --> 00:17:20,150
像这样在这里如此

250
00:17:20,150 --> 00:17:24,500
平等运营商在这里证明了这一点JavaScript，所以我们实际上不知道

251
00:17:24,500 --> 00:17:29,480
事先确切的细节如何平等运营商需要工作

252
00:17:29,480 --> 00:17:32,600
运行时间取决于你的类型发送它，所以我们必须收集反馈

253
00:17:32,600 --> 00:17:36,170
在那也是如此，因为我们有一个字节码，我们有一个插槽

254
00:17:36,170 --> 00:17:39,750
反馈那个矢量来保存我们收集信息

255
00:17:39,750 --> 00:17:43,480
所以我们最后一次手术是在

256
00:17:43,480 --> 00:17:47,620
情况下，我们加载数组不是空的第一个元素出来，再次

257
00:17:47,620 --> 00:17:52,570
这是一个指代插槽的字节码在反馈向量中，让我们一样

258
00:17:52,570 --> 00:17:54,720
执行它，我们可以学习并变得更好

259
00:17:54,720 --> 00:18:00,190
让感觉好起来，让我们看看这是如何

260
00:18:00,190 --> 00:18:03,190
实际上在执行的时候让我们工作

261
00:18:03,190 --> 00:18:07,000
调用我们刚刚在一个例程中的例程

262
00:18:07,000 --> 00:18:10,060
整数值的光线和我们走

263
00:18:10,060 --> 00:18:13,330
通过我会专注于这个

264
00:18:13,330 --> 00:18:19,300
字节代码，就像我们填写的那样通过我们看看是什么

265
00:18:19,300 --> 00:18:24,340
实际上传递给解释器在这种情况下，当特定操作

266
00:18:24,340 --> 00:18:29,230
你开始你要求的功能长度的数组，你的长度

267
00:18:29,230 --> 00:18:32,260
通过我们从那里得到那个财产

268
00:18:32,260 --> 00:18:37,210
数组对象我们第一次看到它在V8里面，再次不会出汗

269
00:18:37,210 --> 00:18:42,760
关于这些东西是什么细节叫我们记录嘿这是一个这是一个

270
00:18:42,760 --> 00:18:45,940
我们有一个内部整数数组

271
00:18:45,940 --> 00:18:50,890
我们在v8中使用称为map的术语样的幻想或没有那么花哨字为

272
00:18:50,890 --> 00:18:56,830
类的描述符或类它的对象的形状描述符目前正在这样看待情况下，我们正在寻找的数组

273
00:18:56,830 --> 00:19:01,600
我们在第一个槽中记住的整数我们首先看到了一组整数

274
00:19:01,600 --> 00:19:06,490
时间和为了做那个操作在整数数组上有一个

275
00:19:06,490 --> 00:19:11,770
处理程序有一个它的代码指针基本上那会在记忆中被记住我们计算的反馈向量

276
00:19:11,770 --> 00:19:14,520
第一次我们第一次看到这个

277
00:19:14,520 --> 00:19:19,510
操作，我们将它们存储以输入弹出后面的向量，以便我们以后可以

278
00:19:19,510 --> 00:19:23,500
快速返回并执行它或更多第二次也快速再次

279
00:19:23,500 --> 00:19:26,190
作为后期歌剧的占位符

280
00:19:26,190 --> 00:19:29,920
与通过填写类型

281
00:19:29,920 --> 00:19:33,700
填写我们知道的反馈向量我们看到的什么类型可以用作

282
00:19:33,700 --> 00:19:36,430
其次提示优化编译器

283
00:19:36,430 --> 00:19:42,040
操作严格平等检查

284
00:19:42,040 --> 00:19:46,060
长度在这里是一个整数值这是一个稍微不同的格式

285
00:19:46,060 --> 00:19:48,070
插槽，我们只记得它是一个

286
00:19:48,070 --> 00:19:53,110
整数，我们看到，最后当我们加载第一个元素

287
00:19:53,110 --> 00:19:57,100
阵列的我们想起相同或我们记录了与我们相同的信息

288
00:19:57,100 --> 00:20:01,270
当我们把握这个长度的时候我们做了它的地图和我们的对象的形状

289
00:20:01,270 --> 00:20:05,590
创建处理程序或分配处理程序到那个时隙和反馈向量

290
00:20:05,590 --> 00:20:11,520
说这里的代码实际上会执行这种类型的操作

291
00:20:11,520 --> 00:20:14,980
这是第一次之后的好地方

292
00:20:14,980 --> 00:20:20,080
我们碰到的是这个代码是什么我们称之为单形如此单形手段

293
00:20:20,080 --> 00:20:24,160
我们为这些操作创建了一个形状

294
00:20:24,160 --> 00:20:29,170
可以根据不同的事情做不同的事情你传入的类型只能看到一个

295
00:20:29,170 --> 00:20:33,160
类型，这对于v8来说是件好事因为下一次围绕在

296
00:20:33,160 --> 00:20:36,460
我们运行它的解释器我们知道是什么我们看到之前我们可以做一些

297
00:20:36,460 --> 00:20:39,550
关于它如何工作的假设下一次假设它保持

298
00:20:39,550 --> 00:20:44,470
和优化编译器时一样当涡扇发动机可以使用时运行

299
00:20:44,470 --> 00:20:49,900
这些假设可以产生更好的代码，所以这个工程很适合

300
00:20:49,900 --> 00:20:52,800
简单的代码变得更加复杂

301
00:20:52,800 --> 00:20:56,350
当你开始介绍不同的

302
00:20:56,350 --> 00:21:00,610
类型，所以我会再次打电话，但这次用一串字符串和

303
00:21:00,610 --> 00:21:06,430
事实证明，V8的实施方式该字符串数组看起来不同

304
00:21:06,430 --> 00:21:10,810
然后执行让我们来看看数组的数字

305
00:21:10,810 --> 00:21:14,320
我们执行时实际发生了什么这个代码是我们执行的第一件事

306
00:21:14,320 --> 00:21:17,380
该数组长度的负载

307
00:21:17,380 --> 00:21:20,830
因为它的形状不同于此

308
00:21:20,830 --> 00:21:26,140
整数阵列的地图是不同的我们必须记录下这个事实和这个事实

309
00:21:26,140 --> 00:21:30,850
我们这样做的方式不再适合在我们必须的反馈向量中

310
00:21:30,850 --> 00:21:34,630
分配一个边数据结构和我们

311
00:21:34,630 --> 00:21:38,590
把两个条目都放在那里我们已经看到了正确的，所以我们已经看到了

312
00:21:38,590 --> 00:21:43,420
我们已经看到了一个整数的形状数组，我们已经看到了一个

313
00:21:43,420 --> 00:21:46,180
对象数组，所以这个信息必须

314
00:21:46,180 --> 00:21:49,570
被存储以供稍后快速执行和

315
00:21:49,570 --> 00:21:55,390
解释器和优化，但你看到它不会变得更多复杂的我们已经有了这个线结构你可以看到的东西是

316
00:21:55,390 --> 00:21:59,740
开始得到一点点复杂的好消息是当我们做的时候

317
00:21:59,740 --> 00:22:03,610
平等运营商它仍然是一个整数，所以保持不变

318
00:22:03,610 --> 00:22:06,850
同样，但当我们要求第一个元件

319
00:22:06,850 --> 00:22:10,800
阵列的形状是不同的，并且

320
00:22:10,800 --> 00:22:15,310
我们再次来记录这个事实，所以如果你看后面的反馈向量

321
00:22:15,310 --> 00:22:19,690
你做了这两个电话您的比你当你不同的条目

322
00:22:19,690 --> 00:22:24,550
因为我们已经第一次跑完了看到了造成的不同类型

323
00:22:24,550 --> 00:22:27,160
某些操作要走我们所说的

324
00:22:27,160 --> 00:22:31,270
多形态许多形状证明了这一点

325
00:22:31,270 --> 00:22:35,860
是困扰着我们的东西多年来的多态操作和

326
00:22:35,860 --> 00:22:38,460
我们在v8中处理多态

327
00:22:38,460 --> 00:22:43,830
直接转化为性能如何

328
00:22:43,830 --> 00:22:46,540
如果我们真的很复杂的系统

329
00:22:46,540 --> 00:22:51,460
处理多态复杂的系统系统往往变得更好，更快

330
00:22:51,460 --> 00:22:55,840
这是我们摔跤的事情这对于一个例子来说很重要

331
00:22:55,840 --> 00:23:01,120
我想现在就给你看看

332
00:23:01,120 --> 00:23:05,170
那种背景知道如何v8从根本上讲如何解释

333
00:23:05,170 --> 00:23:08,380
作品以及我们如何使用这些信息

334
00:23:08,380 --> 00:23:13,090
从类型反馈收集-它会得到输入到优化编译器中

335
00:23:13,090 --> 00:23:16,300
多态性是你的东西必须小心，因为它可以

336
00:23:16,300 --> 00:23:19,420
实际上让你的代码更慢

337
00:23:19,420 --> 00:23:22,870
变得敏锐或我们成了

338
00:23:22,870 --> 00:23:28,750
在这个例子中非常了解这一点我想告诉你现在让我们来看看你

339
00:23:28,750 --> 00:23:34,630
在你的程序中需要一个函数它总结了所有的元素

340
00:23:34,630 --> 00:23:39,340
蛋白甜饼，所以这里是我的一个功能通过手工书写使用某种惯用语

341
00:23:39,340 --> 00:23:44,110
是的，它经历了所有的

342
00:23:44,110 --> 00:23:47,590
第一个数组的元素它只是记住它，否则

343
00:23:47,590 --> 00:23:53,080
它将它添加到它看到的元素或它所拥有的总和已经收集起来了

344
00:23:53,080 --> 00:23:58,570
到那一点是有道理的，我做的是

345
00:23:58,570 --> 00:24:01,990
在这里也写了一个小时间例程

346
00:24:01,990 --> 00:24:05,980
你可以PAP阵列-和它

347
00:24:05,980 --> 00:24:10,950
包装和功能并运行它重新结束并获得一些

348
00:24:10,950 --> 00:24:15,130
统计显着的表现结果并做出判断

349
00:24:15,130 --> 00:24:20,570
快速的事情是可以的，以便让测试例程让我们看看它有多快

350
00:24:20,570 --> 00:24:24,860
是在v8，所以手写一些我

351
00:24:24,860 --> 00:24:28,640
创建一个整数数组并运行它

352
00:24:28,640 --> 00:24:33,050
通过我的基准线束和100

353
00:24:33,050 --> 00:24:36,880
毫秒运行它我认为是关于一百万次没关系，这很不错

354
00:24:36,880 --> 00:24:41,120
然后我用再次在本次运行

355
00:24:41,120 --> 00:24:45,980
所以可能是这样的响起一些钟声，有什么东西

356
00:24:45,980 --> 00:24:48,880
会不一样的在这里正确的

357
00:24:48,880 --> 00:24:54,080
慢了很多，甚至慢得多

358
00:24:54,080 --> 00:24:58,250
尽管阵列比较短，所以也是如此更少的工作要做，但它变慢了

359
00:24:58,250 --> 00:25:01,250
最后我发生了一些事情

360
00:25:01,250 --> 00:25:05,150
会用整数再次运行它阵列中，我通过传递过去

361
00:25:05,150 --> 00:25:10,220
第一次哎，真的很慢

362
00:25:10,220 --> 00:25:14,600
这个预期会让你想要你的程序做到这一点，这是不是

363
00:25:14,600 --> 00:25:19,850
一致的基准性能我们希望你能做些什么一旦你再次做到这一点，你就会得到

364
00:25:19,850 --> 00:25:25,550
同样的结果在正确性和中在表现好，所以是什么

365
00:25:25,550 --> 00:25:29,050
去这里为什么这么慢

366
00:25:29,050 --> 00:25:35,330
任何人猜测多态性和我们

367
00:25:35,330 --> 00:25:40,550
谈到为什么这是怎样的一个陷阱v8可能陷入你会注意到

368
00:25:40,550 --> 00:25:44,510
在一些函数的迭代中

369
00:25:44,510 --> 00:25:48,590
所做的事情就是取材每个元素和我们使用这个

370
00:25:48,590 --> 00:25:52,580
构建此为构建体，其

371
00:25:52,580 --> 00:25:56,390
在封面下没有什么比那种我之前做过的工作

372
00:25:56,390 --> 00:26:00,650
在哪里看它的长度数组并且需要当前元素

373
00:26:00,650 --> 00:26:03,980
它在它的阵列之外封面需要相同的机器

374
00:26:03,980 --> 00:26:08,559
我们在我展示的例子中看到的之前和它运行它有相同的

375
00:26:08,559 --> 00:26:12,500
危及如果你的隐患将它传递给不同类型的数组

376
00:26:12,500 --> 00:26:15,800
那么它会为这些生成多态性

377
00:26:15,800 --> 00:26:20,300
它甚至会获得更多一点在这个微妙的，因为

378
00:26:20,300 --> 00:26:24,170
当我们将这些元素加在一起的时候

379
00:26:24,170 --> 00:26:28,340
运算符在JavaScript中加入

380
00:26:28,340 --> 00:26:33,150
戴着许多帽子，它可以是一个整数加成

381
00:26:33,150 --> 00:26:37,260
在这种情况下你会得到整数加法或者它可以是字符串连接

382
00:26:37,260 --> 00:26:41,880
有点令人惊讶，但它的作品所以我们第一次运行总和

383
00:26:41,880 --> 00:26:44,130
函数与整数数组我们得到一个

384
00:26:44,130 --> 00:26:49,070
整数结果，加上是一个整数操作虽然第二次

385
00:26:49,070 --> 00:26:52,800
就像我们在什么时候看到一个多态从数组中获取元素

386
00:26:52,800 --> 00:26:56,280
当我们添加元素首次将它们排列在一起

387
00:26:56,280 --> 00:27:00,750
整数秒他们是我们的字符串必须有一个更复杂的

388
00:27:00,750 --> 00:27:05,250
实现它成为它的多态性变得更慢，所以这就是为什么

389
00:27:05,250 --> 00:27:11,840
手写的实现是慢没关系

390
00:27:11,840 --> 00:27:15,960
也许VA团队可以做得更好对，我们有这些东西叫

391
00:27:15,960 --> 00:27:18,510
如果您了解JavaScript，则可以使用内置插件

392
00:27:18,510 --> 00:27:23,309
相当不错，你知道那个许多内置的原型

393
00:27:23,309 --> 00:27:26,940
对象有一大堆实用工具Fink功能和那些功能都是

394
00:27:26,940 --> 00:27:31,260
在Ekman中非常详细地定义脚本规范，如果你阅读规范

395
00:27:31,260 --> 00:27:36,390
它说这正是它正在发生的事情当你为每个或这个电话打电话时都要这么做这正是我们要做的时

396
00:27:36,390 --> 00:27:42,420
你可以调用数组索引和好东西

397
00:27:42,420 --> 00:27:48,260
关于这件事是因为我们有这个合约由集群定义您认为给予虚拟机的脚本

398
00:27:48,260 --> 00:27:53,250
实施v8工程师很多有机会制作这些内置插件

399
00:27:53,250 --> 00:27:57,240
因为它们随v8一起发布而更快我们可以做所有的伎俩

400
00:27:57,240 --> 00:28:02,370
事先，你可以通过使用获益这些内置插件使用所有这些

401
00:28:02,370 --> 00:28:06,630
那我们把那些正确的确定，所以

402
00:28:06,630 --> 00:28:09,300
事实证明这是一个内置的

403
00:28:09,300 --> 00:28:12,960
这是内置的减少，所以这是

404
00:28:12,960 --> 00:28:16,080
使用es6语法我得到了一个小箭头

405
00:28:16,080 --> 00:28:21,179
功能在这里我已经习惯了表达了我在试图做的事情

406
00:28:21,179 --> 00:28:25,380
总和功能我有一个更高的水平通过使用reduce来表达我的意图

407
00:28:25,380 --> 00:28:30,360
内置在阵列上并提供了这个箭头函数来告诉它你做了什么

408
00:28:30,360 --> 00:28:35,130
为每个元素做这样的总和本质上功能确实是什么

409
00:28:35,130 --> 00:28:40,170
手写代码的确有点不同用语言结构包装我的意图

410
00:28:40,170 --> 00:28:42,900
一个明确的语言陈述是

411
00:28:42,900 --> 00:28:46,919
语言的这些内置插件之一这很好地定义了它的行为

412
00:28:46,919 --> 00:28:51,389
发现所以你认为这可能是哇更快，这会更好

413
00:28:51,389 --> 00:28:56,129
因为v8工程师已经保重了这个井如果你运行相同

414
00:28:56,129 --> 00:28:57,419
基准，我以前

415
00:28:57,419 --> 00:29:02,720
直到铬58这里发生了什么

416
00:29:02,720 --> 00:29:08,450
整数数组，伤害

417
00:29:08,450 --> 00:29:12,450
凯瑟尔虽然运行它的结果

418
00:29:12,450 --> 00:29:16,200
字符串好的稍好，但仍然没有

419
00:29:16,200 --> 00:29:22,909
很快，第三次通过更快

420
00:29:22,909 --> 00:29:27,419
这里发生了什么好的，就是这样

421
00:29:27,419 --> 00:29:31,190
几乎比做它慢五倍手工为什么你会使用内置的

422
00:29:31,190 --> 00:29:35,730
我们拥有的所有专业知识似乎没有帮助它

423
00:29:35,730 --> 00:29:40,070
不幸的是为什么直到铬58

424
00:29:40,070 --> 00:29:44,970
我们的许多内置插件和具体这个减少的buildin就是我们所说的

425
00:29:44,970 --> 00:29:47,249
自我托管它是一种诱人的

426
00:29:47,249 --> 00:29:51,809
关于何时构建虚拟机的想法你知道我们要建造一个

427
00:29:51,809 --> 00:29:54,840
编译器，我们将建立一个口译员，如果我们表达一切

428
00:29:54,840 --> 00:29:59,519
就JavaScript而言无论它是什么那么在那个翻译和那些

429
00:29:59,519 --> 00:30:04,950
那会优化编译器只是照顾它的权利也不会我们的问题，因为编译器聪明足够

430
00:30:04,950 --> 00:30:08,759
所以内置的减少写得像这个

431
00:30:08,759 --> 00:30:13,409
直到铬58，你会看到它比手写的要长得多

432
00:30:13,409 --> 00:30:17,940
版本的原因是因为ACMA脚本规范

433
00:30:17,940 --> 00:30:22,919
内置实际上很长并且具有大量的边缘情况下，很多事情必须得到处理和表达

434
00:30:22,919 --> 00:30:27,119
作为JavaScript有一个阻抗

435
00:30:27,119 --> 00:30:31,980
反正不匹配，无论是那

436
00:30:31,980 --> 00:30:35,730
你还有一点点时间基本上存在相同的问题

437
00:30:35,730 --> 00:30:39,869
多态现象可能在其中这段代码是因为它是JavaScript代码

438
00:30:39,869 --> 00:30:43,830
如果您使用自托管来表示

439
00:30:43,830 --> 00:30:48,809
排序的这些非常常见的内置你运行相同的功能块

440
00:30:48,809 --> 00:30:51,629
您会在内置插件中冒风险

441
00:30:51,629 --> 00:30:55,950
得到你的应用程序代码，所以是什么

442
00:30:55,950 --> 00:31:00,390
观察不要药不自己主机内置

443
00:31:00,390 --> 00:31:05,460
优化他们为他们优化他们和这里的观察有点儿

444
00:31:05,460 --> 00:31:10,289
比更深追溯到排序我在原来的观察

445
00:31:10,289 --> 00:31:15,740
这是介绍的开始如果某件事情对你来说很重要

446
00:31:15,740 --> 00:31:20,669
表现还是别的不成熟优化甚至排序构建一个

447
00:31:20,669 --> 00:31:25,559
心理模型围绕你的想法您将稍后使用来优化

448
00:31:25,559 --> 00:31:28,019
我们认为我们会有一个伟大的例子编译器，我们会有一个伟大的

449
00:31:28,019 --> 00:31:31,710
解释者只会解决这个问题对我们来说这个问题正在推动

450
00:31:31,710 --> 00:31:34,919
技术债务是那种制作以后可能会出现的假设

451
00:31:34,919 --> 00:31:39,480
咬你，他们在这种情况下做所以另一种方式来看待，这是说

452
00:31:39,480 --> 00:31:44,850
好吧，如果它真的很重要性能为什么我们不建立一个解决方案，这是定制

453
00:31:44,850 --> 00:31:51,000
对于我们的使用案例来说，这是轮到

454
00:31:51,000 --> 00:31:55,529
我们在过去几年中做了什么这是我想和你谈谈的几年

455
00:31:55,529 --> 00:31:57,990
我们如何做一点，由于我认为这是一种冷静这是一个有点

456
00:31:57,990 --> 00:32:02,519
位向你展示了我们是什么实际上在v8中做这些

457
00:32:02,519 --> 00:32:06,690
你可能会问得更快

458
00:32:06,690 --> 00:32:11,279
因为内置插件是如此普遍使用在许多不同的情况下，我们有

459
00:32:11,279 --> 00:32:14,220
关于他们的专业知识因为我们是虚拟现实工程师，我们有

460
00:32:14,220 --> 00:32:17,940
这个规范我们可以做到这一切如果我们事先工作会很好

461
00:32:17,940 --> 00:32:22,679
对什么是超级严格的控制因为在内置中生成

462
00:32:22,679 --> 00:32:28,409
JavaScript代码就是这样的我们做自我时的抽象托管内置我们有点失落信息有一个片段

463
00:32:28,409 --> 00:32:33,330
阻抗不匹配我们失去了一些像这样的帐篷的表现是

464
00:32:33,330 --> 00:32:37,919
重要的是快速，也许使用一些这里的诡计你不能这样做

465
00:32:37,919 --> 00:32:41,370
JavaScript自行托管内置if

466
00:32:41,370 --> 00:32:45,659
有一种方法可以锻炼在一个更低的水平，将是

467
00:32:45,659 --> 00:32:50,669
很好，所以也许JavaScript不是正确的工具，我们如何使用

468
00:32:50,669 --> 00:32:54,240
C++的权利，我们可以实现这些事实证明，在C++中嵌入内置

469
00:32:54,240 --> 00:32:58,169
这是一种棘手的一对夫妇我无法做到的原因

470
00:32:58,169 --> 00:33:01,529
第一个是我们之前的v8版本

471
00:33:01,529 --> 00:33:06,360
执行JavaScript代码我们有一个ABI我们有一个

472
00:33:06,360 --> 00:33:11,850
接口代码相互调用的方式在执行时在Java内部

473
00:33:11,850 --> 00:33:13,710
那个JavaScript

474
00:33:13,710 --> 00:33:17,940
不同于C++ABI，因为

475
00:33:17,940 --> 00:33:21,960
他们不一样真的很难没有一堆额外的互操作

476
00:33:21,960 --> 00:33:26,899
机器发现机器返回是不是很贵？

477
00:33:26,899 --> 00:33:30,899
性能的角度来看，它是真的

478
00:33:30,899 --> 00:33:35,970
不是一个好主意，做，在大多数情况也是这样的

479
00:33:35,970 --> 00:33:40,549
所谓的延期代码，如果我们有一个内置有快速路径

480
00:33:40,549 --> 00:33:46,440
例如，如果你加入了它正在迭代一些事情

481
00:33:46,440 --> 00:33:50,010
数组，你可以传入的情况下

482
00:33:50,010 --> 00:33:53,909
减少内置你可能已经通过它这不是一个数组和圣诞节

483
00:33:53,909 --> 00:33:58,169
crip确切地定义了发生的事情那种情况，但如果是这样的话

484
00:33:58,169 --> 00:34:02,460
我们知道我们可以做得非常快我们很快就表达了

485
00:34:02,460 --> 00:34:08,310
这在我们的内置插件中我们有一个快速路径我们运行一些检查，如果这些检查持有我们做快速普通

486
00:34:08,310 --> 00:34:11,879
代码，否则我们去其他地方做

487
00:34:11,879 --> 00:34:16,500
一些更昂贵，然后跳回来并恢复它的位置

488
00:34:16,500 --> 00:34:22,349
感觉好，所以他们有内联快速路径轮廓慢的路径很难做到

489
00:34:22,349 --> 00:34:26,429
这在C++中，因为你实际上从字面上来说，希望快速路径是

490
00:34:26,429 --> 00:34:30,929
内联要控制如何编译器生成的代码很难做到

491
00:34:30,929 --> 00:34:34,649
在C++中，我们也有一个GC垃圾

492
00:34:34,649 --> 00:34:38,460
收藏者在v8和我们的事情之一

493
00:34:38,460 --> 00:34:41,990
想要做的就是能够有指针这不仅仅是你知道的数据

494
00:34:41,990 --> 00:34:45,810
结构在我们想要的c++堆上有对对象的指针和

495
00:34:45,810 --> 00:34:49,080
因为我们GCGC实际上移动了

496
00:34:49,080 --> 00:34:54,060
反对它压缩它四处移动它们为了提高效率，我们很重要

497
00:34:54,060 --> 00:34:58,290
知道这些对象中的每一个在哪里指针是和专门处理它

498
00:34:58,290 --> 00:35:02,460
情况下有垃圾收集和在C++中这样做确实很困难

499
00:35:02,460 --> 00:35:05,070
这是哦，这是非常困难的

500
00:35:05,070 --> 00:35:09,180
指定这里有一个指针，它是将成为一个对象指针和不

501
00:35:09,180 --> 00:35:14,880
不管发生什么事，你必须告诉我当你用这个指针做任何事时在编译器和C++编译器中它

502
00:35:14,880 --> 00:35:19,020
它只是不工作，你必须建立真正的间接

503
00:35:19,020 --> 00:35:21,630
昂贵的东西我们无法工作

504
00:35:21,630 --> 00:35:25,560
做内置是我们做这些我们做尾巴称它是这种变体的一种

505
00:35:25,560 --> 00:35:30,779
延期代码将内联共同案件后做一些检查，如果我们根本无法处理它

506
00:35:30,779 --> 00:35:35,160
然后我们会从快速的尾巴中唤醒

507
00:35:35,160 --> 00:35:39,900
实现到C++实现中这有所有这些缺点，但我们

508
00:35:39,900 --> 00:35:44,839
不关心，因为它几乎从不发生我们只需要缓慢实现符合规范

509
00:35:44,839 --> 00:35:49,109
好吧，所以C++不是正确的工具

510
00:35:49,109 --> 00:35:52,349
关于我们汇编所有内容语言权利，这是他们所有的快速

511
00:35:52,349 --> 00:35:55,680
那控制结果一会儿我们

512
00:35:55,680 --> 00:35:59,210
有点这样做，我们积累了

513
00:35:59,210 --> 00:36:03,799
每行45,000行汇编代码我们有九个平台，

514
00:36:03,799 --> 00:36:07,589
如果你能想象它有点转身过了一段时间后变成了一团糟，因为它是

515
00:36:07,589 --> 00:36:12,240
真的很难表达意图在编写汇编语言时你可以

516
00:36:12,240 --> 00:36:16,769
只显示坚果和螺栓，然后转动

517
00:36:16,769 --> 00:36:21,599
这也不是一个好主意所以有什么我们可以做的

518
00:36:21,599 --> 00:36:26,789
让我们从手写中获取想法平台内置了这些组件

519
00:36:26,789 --> 00:36:32,430
我们有他们真的很快，但是不可能维持有

520
00:36:32,430 --> 00:36:36,809
我们可以这样做比这更好的它拥有所有的

521
00:36:36,809 --> 00:36:42,440
优点，但也许不那么复杂我们可以更容易管理

522
00:36:42,440 --> 00:36:47,460
所以涡轮风扇我们有这个编译器技术有能力

523
00:36:47,460 --> 00:36:49,500
生成机器代码优化的机器

524
00:36:49,500 --> 00:36:53,549
代码在九个不同的平台上

525
00:36:53,549 --> 00:36:58,440
有这个中间表示代表着高运营

526
00:36:58,440 --> 00:37:02,880
级别添加这两个32位数字的加载这个内存不足的值会使这个调用

527
00:37:02,880 --> 00:37:07,259
到这个功能，并通过揭露我们可以以正确的方式接口

528
00:37:07,259 --> 00:37:12,089
准确描述我们想要做什么几乎是一个组装水平，但在中

529
00:37:12,089 --> 00:37:15,720
跨平台的方式等等界面

530
00:37:15,720 --> 00:37:19,470
或者我们所称的组件代码存根汇编器就是

531
00:37:19,470 --> 00:37:24,029
因为我们称之为事物而非常困惑有时候是存根，有时候是内置的

532
00:37:24,029 --> 00:37:28,710
这是一个混乱，但无论如何，我们建立内置的代码具有

533
00:37:28,710 --> 00:37:32,250
汇编程序好，让我们来看看

534
00:37:32,250 --> 00:37:35,490
检查每张纸是什么给了我们

535
00:37:35,490 --> 00:37:39,630
GC支持证明了这一点

536
00:37:39,630 --> 00:37:42,360
汇编语言真的很难，因为你有同样的问题，你

537
00:37:42,360 --> 00:37:46,500
不会c++以某种方式注释事物明确这个东西在这个寄存器

538
00:37:46,500 --> 00:37:50,880
在这个时候是一个对象哇，得到真的难以维持

539
00:37:50,880 --> 00:37:55,080
而你的代码停止汇编创造价值并且你管理他们的一部分

540
00:37:55,080 --> 00:37:58,500
的界面可以让你表达嘿这件事会成为一个对象和

541
00:37:58,500 --> 00:38:04,380
这将是其整个生命周期中只顺便为我做正确的事情把它放在一个注册表中，如果你可以的话

542
00:38:04,380 --> 00:38:09,300
正确的事情，所以你可以免费获得寄存器分配的种类

543
00:38:09,300 --> 00:38:12,510
提到提到我的一个同事喜欢打电话给手写

544
00:38:12,510 --> 00:38:16,350
汇编版本的寄存器分配在大脑寄存器分配结果

545
00:38:16,350 --> 00:38:19,980
你做错了真的很难所有的时间和它几乎创造

546
00:38:19,980 --> 00:38:24,270
因为我们已经不可能找到错误一个优化编译器和turbofan如果

547
00:38:24,270 --> 00:38:28,200
我们使用后端为那个有一个寄存器分配器，你不必

548
00:38:28,200 --> 00:38:30,900
在这些问题上解决这些问题

549
00:38:30,900 --> 00:38:34,680
用代码子程序集编写存根因为寄存器分配已完成

550
00:38:34,680 --> 00:38:37,050
对你来说，它是通过机器完成的，而不是通过

551
00:38:37,050 --> 00:38:41,760
脑所有这些阻抗

552
00:38:41,760 --> 00:38:46,820
我与ABI提到的不匹配与之间来回呼叫

553
00:38:46,820 --> 00:38:49,380
内置插件和JavaScript代码

554
00:38:49,380 --> 00:38:54,060
如果你用手写东西的话，它会变成asan和汇编语言，它是非常

555
00:38:54,060 --> 00:38:58,320
难以维持很努力在做的CSA你基本上只是创建一个

556
00:38:58,320 --> 00:39:02,369
描述符，然后说我想打电话这个功能和它有这个特殊之处

557
00:39:02,369 --> 00:39:05,310
一组参数将这些寄存器放入从这些值或正确的地方

558
00:39:05,310 --> 00:39:09,330
无论是做正确的事情还是事情为您生成九个代码

559
00:39:09,330 --> 00:39:13,170
平台，当你必须这样做如果你在汇编中写下它们，请亲自动手

560
00:39:13,170 --> 00:39:18,119
我们有一些非常整齐的语言在所有的后端进行优化

561
00:39:18,119 --> 00:39:22,950
我们的代码生成器所以我们做指令选择这意味着在英特尔平台上

562
00:39:22,950 --> 00:39:26,670
我们可以结合寻址模式让他们更有效率，我们有一个

563
00:39:26,670 --> 00:39:31,109
指令调度器这是一些东西这是真的很难做手和

564
00:39:31,109 --> 00:39:35,340
组装我们的指令调度程序创建的简化模型的模型

565
00:39:35,340 --> 00:39:39,210
的处理器，并计算出我是否重新排列这些指令中的一部分

566
00:39:39,210 --> 00:39:45,080
你会得到更快的代码大规模这样做在汇编语言中确实很难

567
00:39:45,080 --> 00:39:49,090
最后一件事是工具集成事实证明

568
00:39:49,090 --> 00:39:53,470
作为子汇编程序可以生成的代码与之相关的正确记录

569
00:39:53,470 --> 00:39:58,210
它生成的代码让你可以使用Linuxperf集成

570
00:39:58,210 --> 00:40:01,450
看看我们在哪里花时间这些内置插件，如果你这样做

571
00:40:01,450 --> 00:40:04,750
大会你将不得不建立这些手动记录完全无法维护

572
00:40:04,750 --> 00:40:08,230
所以这是一件好事编写一些我们现在可以生成的汇编程序

573
00:40:08,230 --> 00:40:11,710
我们所有平台的规模都是这些

574
00:40:11,710 --> 00:40:16,420
为自定义的内置插件我们需要那么如何功能

575
00:40:16,420 --> 00:40:21,670
这是怎么回事呢？在一天结束时结束，让我们来

576
00:40:21,670 --> 00:40:27,160
再次尝试整数数组与镀铬63只有CSA

577
00:40:27,160 --> 00:40:30,340
的降低建于权利，使版本

578
00:40:30,340 --> 00:40:35,290
它有一个定制版本的书面生成漂亮的CSA界面

579
00:40:35,290 --> 00:40:41,290
所以9个平台的汇编代码很好你第一次跑的很好

580
00:40:41,290 --> 00:40:43,600
不好，还有一些事情要做

581
00:40:43,600 --> 00:40:47,410
在这里不，我不知道那里的那个C

582
00:40:47,410 --> 00:40:55,060
无论如何，但来自弦乐

583
00:40:55,060 --> 00:41:00,460
如果我们的速度已经很快，那很好为什么这可能是这种情况

584
00:41:00,460 --> 00:41:04,750
那第二个呃是的，因为C

585
00:41:04,750 --> 00:41:08,830
这是正确的，所以我不建议你

586
00:41:08,830 --> 00:41:14,310
随机将C代码添加到Java脚本中

587
00:41:14,310 --> 00:41:16,570
那完全不是故意的，这是

588
00:41:16,570 --> 00:41:22,380
反正没有好消息的一致性是

589
00:41:22,380 --> 00:41:27,430
当你运行整数数组时它再次是一致的，有一个快乐的

590
00:41:27,430 --> 00:41:30,900
结束这个故事使我承担

591
00:41:30,900 --> 00:41:34,720
我们可以做更多的事情虽然我们对这些仍然很慢

592
00:41:34,720 --> 00:41:39,190
整数数组的好处就是这样实际上这里有两件事

593
00:41:39,190 --> 00:41:43,750
请记住我给你看的例子最初与减少它称之为

594
00:41:43,750 --> 00:41:48,430
箭头函数为我们的每个元素随着时间的推移，你可以想象得到

595
00:41:48,430 --> 00:41:53,050
我们首先调用reduce函数

596
00:41:53,050 --> 00:41:57,790
我们花了一些时间在它做一些设置和一些检查，然后

597
00:41:57,790 --> 00:42:01,510
它回调的回调函数做的工作增加了两个数字，它就这样了

598
00:42:01,510 --> 00:42:04,450
背部它回到箭头功能添加

599
00:42:04,450 --> 00:42:08,710
两个数字可以回到mm-hmm对，所以你在这里得到的想法我不会

600
00:42:08,710 --> 00:42:14,290
经历这一切，但返回并这么多问题是怎么回事

601
00:42:14,290 --> 00:42:18,850
问题在于回拨和之间的减少内置其中

602
00:42:18,850 --> 00:42:22,930
是真快，现在但是那个箭头函数有很多

603
00:42:22,930 --> 00:42:27,940
开销，如果工作的开销你正在做箭头内部

604
00:42:27,940 --> 00:42:33,310
功能加运算非常小呼叫来回

605
00:42:33,310 --> 00:42:37,060
实际上远远超过了更贵实际上你在做的工作

606
00:42:37,060 --> 00:42:40,260
回调内HMM

607
00:42:40,260 --> 00:42:44,980
那么我们如何很好地解决这个问题有这个优化编译器涡扇

608
00:42:44,980 --> 00:42:50,170
我们所做的是我们教过的涡轮风扇，当它看到一个呼叫

609
00:42:50,170 --> 00:42:55,630
减少并知道该功能这被称为回到满足一定

610
00:42:55,630 --> 00:43:00,730
标准，它足够小，而且月亮的相位是一致的，而且是相对的

611
00:43:00,730 --> 00:43:01,900
每个月的第三个星期二

612
00:43:01,900 --> 00:43:06,850
它可以内联运行，并

613
00:43:06,850 --> 00:43:11,530
当你发送你的代码时生成到它生成的优化编译器

614
00:43:11,530 --> 00:43:15,340
一个代码的所有的减少

615
00:43:15,340 --> 00:43:19,750
包括呼叫的内联版本回到所以它看起来更像这对好

616
00:43:19,750 --> 00:43:25,210
而不是调用来回有一个优化生成的块

617
00:43:25,210 --> 00:43:29,080
机器代码，这两个我都可以

618
00:43:29,080 --> 00:43:33,160
可能是啊猜测其实哦，是的一个

619
00:43:33,160 --> 00:43:36,850
在这里添加的东西我们谈到了多态性是一件坏事证明

620
00:43:36,850 --> 00:43:39,430
我们可以玩一些技巧当我们得到时，优化apado

621
00:43:39,430 --> 00:43:43,390
围绕优化我们可以有记录了的方式在这个地方

622
00:43:43,390 --> 00:43:47,620
你称之为减少它只有得到用整数数组调用它

623
00:43:47,620 --> 00:43:51,100
记得在代码中的地方如果你有，请致电减少

624
00:43:51,100 --> 00:43:54,610
你的代码的一部分，做字符串减少操作和另一部分

625
00:43:54,610 --> 00:43:59,170
你的代码，不会的，你知道它有整数数组，它适用于这些

626
00:43:59,170 --> 00:44:04,930
两件事情将分开处理并且类型反馈将被分开以这样的方式，我们可以专注和

627
00:44:04,930 --> 00:44:07,920
使它对这些呼叫站点是单形的

628
00:44:07,920 --> 00:44:12,790
所有正确的时间，所以让我们来做吧

629
00:44:12,790 --> 00:44:15,559
让我们再次做基准

630
00:44:15,559 --> 00:44:21,759
这次是涡轮风扇

631
00:44:21,759 --> 00:44:26,390
很不错噢，那就是我

632
00:44:26,390 --> 00:44:29,420
谢谢，但无论如何，让我们这样做的

633
00:44:29,420 --> 00:44:34,369
我们很好有趣的是，在这里要注意的是

634
00:44:34,369 --> 00:44:39,109
实际上比整数数组快有意义的是它是一个更小的阵列

635
00:44:39,109 --> 00:44:43,099
它应该做更少的工作和运行

636
00:44:43,099 --> 00:44:49,430
它再次不完美，我还是相当不错的

637
00:44:49,430 --> 00:44:54,170
这是诚实的权利，我还是更好比之前我们看到的任何东西都要好

638
00:44:54,170 --> 00:44:58,160
看看这些数字比较第一个就是让我们开始

639
00:44:58,160 --> 00:45:02,089
与自我托管的内置我们会有铬58和

640
00:45:02,089 --> 00:45:05,719
在使用那个测试之前整数数组

641
00:45:05,719 --> 00:45:10,219
第一次是字符串数组第二次和那么第三次测试的第三次是

642
00:45:10,219 --> 00:45:14,869
整数数组作为第二次基准自我托管的内置是一个

643
00:45:14,869 --> 00:45:19,849
所以任何事情都会比这更快越小越好越好

644
00:45:19,849 --> 00:45:23,779
你在这里注意到的第一件事是如果你有一个手写版本，但你使用

645
00:45:23,779 --> 00:45:26,959
它就像我们拥有的图书馆一样该手写总和功能，如果你使用

646
00:45:26,959 --> 00:45:31,069
它在一堆不同的地方然后如果你的单形是第一个，那很好

647
00:45:31,069 --> 00:45:36,439
当你称它为超级时，它确实是速度很快，但你会看到它逐渐地获得随着代码变得越来越复杂，情况越糟

648
00:45:36,439 --> 00:45:39,199
这不是可预测的基准

649
00:45:39,199 --> 00:45:42,910
CSA的表现没问题

650
00:45:42,910 --> 00:45:45,769
单态情况比较慢，但是

651
00:45:45,769 --> 00:45:49,400
如果你真的在复杂的代码中立即处理字符串或你正在处理

652
00:45:49,400 --> 00:45:53,079
多态性已经更快了比自建的内置和

653
00:45:53,079 --> 00:45:56,569
如果不比的话可比

654
00:45:56,569 --> 00:46:00,890
手写版本，最后如果你使用涡轮风扇内嵌版本

655
00:46:00,890 --> 00:46:04,309
在Chrome66或更高版本，你会看到，

656
00:46:04,309 --> 00:46:08,269
它比任何一个都快，速度更快比在手写版本

657
00:46:08,269 --> 00:46:12,229
单形的情况下，为什么这是一个重要的是这还记得我告诉过你

658
00:46:12,229 --> 00:46:17,449
我们有这个特殊的技术，因为我们阅读规范和东西结果如果你看一下减少功能

659
00:46:17,449 --> 00:46:22,099
在规范中它留下了一些您可能必须执行的步骤

660
00:46:22,099 --> 00:46:26,449
实际上从技术上来说是正确的你使用你的手写循环，所以我们有

661
00:46:26,449 --> 00:46:29,430
操作或优化的机会你可能不会

662
00:46:29,430 --> 00:46:32,940
手头上写的代码如此重要

663
00:46:32,940 --> 00:46:36,300
这里学到的教训表达意图理由是这些内置了这些

664
00:46:36,300 --> 00:46:40,859
更高阶的功能是有的允许你说出你想要做什么

665
00:46:40,859 --> 00:46:45,900
高水平，让编译器尝试用你的意图优化它，而不是

666
00:46:45,900 --> 00:46:51,240
试图找出你的意图就像我们在自己托管的那样从个人陈述中内置

667
00:46:51,240 --> 00:46:55,940
这是一个非常好的方面

668
00:46:55,940 --> 00:47:01,500
减少内置和许多其他的实际上在这一点上铬66或

669
00:47:01,500 --> 00:47:05,520
后来很低-这是一个很棒的图书馆很长一段时间来获得的唯一途径

670
00:47:05,520 --> 00:47:09,930
对于一些真正不错的表现数组内置，如果你比较低-现在

671
00:47:09,930 --> 00:47:13,849
与最新版本的v8搭配使用

672
00:47:13,849 --> 00:47:18,359
点火和涡轮风扇和这些建筑物的衬里它的速度更快

673
00:47:18,359 --> 00:47:21,960
使用V8引擎的内置插件，而不是那种

674
00:47:21,960 --> 00:47:26,069
这些标准解决方案那好吧是好消息

675
00:47:26,069 --> 00:47:30,390
外卖的设计和最小

676
00:47:30,390 --> 00:47:35,099
具体而言，这是我们学到的一课非常困难的方式不要过度优化

677
00:47:35,099 --> 00:47:39,770
过早地优化或建立复杂性变成你可能永远不需要的东西

678
00:47:39,770 --> 00:47:43,230
正确的惯用JavaScript使用

679
00:47:43,230 --> 00:47:48,089
es6和提供的功能JavaScript的新版本

680
00:47:48,089 --> 00:47:52,260
JavaScript语言，因为他们允许你高度表达你的意图

681
00:47:52,260 --> 00:47:57,270
这给了我们更多的机会等级优化你的代码选择正确的

682
00:47:57,270 --> 00:48:00,960
基准，因为这些基准将会如果他们是这样的话，请绕过来缠住你

683
00:48:00,960 --> 00:48:05,730
错误的测量和仔细调整花时间实际创建一个框架

684
00:48:05,730 --> 00:48:09,210
衡量你关心的事情关于这样你就可以做到这一点

